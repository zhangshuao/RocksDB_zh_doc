# 写缓冲区管理器

Write buffer manager帮助用户控制memtables跨多个列族 或 DB实例使用的内存总量。通过这样做，用户可以实现:
1.尝试限制在阈值下跨多个列族和DBs的memtable总使用量。
2.花费memtable内存使用来阻塞缓存

写缓冲区管理器的使用类似于rate_limiter和sst_file_manager。用户创建一个写缓冲区管理器对象，并将其传递给您希望由该对象控制其memtable大小的列族或DBs的所有选项。
有关如何使用它，请参阅write_buffer_manager.h的代码注释。

## 限制memtables的总内存

在创建写缓冲区管理器对象时，会给出内存限制。RocksDB将尝试将总内存限制在这个限制之下。

在版本5.6或更高版本中，如果可变memtable的总大小超过限制的90%，则将在插入的数据库的一个列族上触发刷新。
如果实际内存超过了限制，即使可变memtable的总大小低于90%，也可能触发更积极的刷新。
在5.6版本之前，如果可变memtable的总大小超过限制，将触发刷新。

在5.6或更高版本中，内存被计算为分配给arena的总内存，即使memtable可能还没有使用其中的一些内存。
在早期版本中，内存被计算为memtables实际使用的内存。

## memtable中用于阻塞缓存的内存成本

从5.6版开始，用户可以将RocksDB设置为memtable用来阻塞缓存的内存成本。无论是否启用memtable内存限制，都可能发生这种情况。

在大多数情况下，块缓存中实际使用的块仅占块缓存中数据的一小部分，因此当用户启用此功能时，块缓存容量将涵盖块缓存和memtable的内存使用量。如果用户还启用了cache_index_and_filter_blocks，那么RocksDB内存的三种主要用途将被一个上限所限制。

下面是它是如何实现的。对于分配给memtable的每1MB内存，WriteBufferManager将把虚拟的1MB条目放到块缓存中，以便块缓存能够正确地跟踪大小，并在需要时驱逐块以腾出空间。
如果memtable使用的内存减少，WriteBufferManager不会立即删除虚拟块，而是在内存使用量显著下降时缓慢释放它们。
这是因为memtable内存自然是上下浮动的，我们尽量减少阻塞缓存的干扰。

要启用此功能，

* 将使用的块缓存传递给将要使用的WriteBufferManager。
* 仍然将WriteBufferManager参数作为您希望RocksDB用于memtables的最大内存传递。
* 将块缓存的容量设置为用于缓存数据块和memtables的内存的总和。

