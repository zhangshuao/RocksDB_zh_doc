# 介绍

Level紧凑化风格是RocksDB的默认紧凑化风格，因此也是用户中使用最广泛的紧凑化风格。
有时，用户很好奇,级别压缩如何选择要在每个压缩中压缩哪些文件。
在这个wiki中，我们将详细讨论这个主题，已节省您阅读代码的时间。

## 步骤

1.从级别0到最高级别，选择第一个级别Lb,该级别的得分大于1作为压缩基准级别。

2.确定压缩输出级别Lo = Lb + 1

3.根据不同的压缩优先级选项，找到应该以最高优先级压缩的第一个文件。
如果Lo上的文件或它的父文件(重叠的文件的键范围)正在被另一个压缩作业压缩，那么跳到具有第二优先级的文件，直到找到一个候选文件。将此文件添加到压缩输入中。

4.继续扩展输入，直到我们确定输入中的文件和周围的文件之间有一个"干净的"边界。
这将确保在压缩过程中不会丢失键的任何部分。例如，我们有五个文件的关键范围:

    f1[a1 a2] f2[a3 a4] f3[a4 a6] f4[a6 a7] f5[a8 a9]

如果我们在步骤3中选择f3，那么在步骤4中，我们必须将输入从{f3}扩展到{f2, f3, f4}，因为f2和f3的边界是连续的，f3和f4也是连续的。
两个文件可能共享同一个用户密钥边界的原因是RocksDB将internal alkey存储在由用户密钥、密钥类型序列号组成的文件中。
因此，文件可以存储多个具有相同用户密钥的内部密钥。因此，如果发生压缩，所有具有相同用户键的内部键都必须完全压缩。

5.检查当前输入中的文件是否与正在压缩的任何文件重叠。否则，请尝试找到任何可用的手动压缩。如果没有，则终止此压缩选择作业。

6.找到所有在输入中与文件重叠的Lo文件，并按步骤4中的相同方式展开它们，直到找到Lo上的文件的"干净分割"。
如果正在压缩这些文件中的任何一个，请中止此压缩选择作业。
否则，将它们放入output_level_input。

7.一个可选的优化步骤。看看我们是否可以进一步增加Lb上的输入数量，而不改变我们拾取的Lo文件的数量。
如果这将导致Lb为某些用户密钥包含InternalKey，而为相同的用户密钥排除其他InternalKey，则我们也选择不进行扩展，即，"a non-clean cut"。
当一个用户键跨多个文件时可能会发生这种情况。前面的句子可能会被单词搞混，所以我在这里举一个例子来说明这种扩展优化。

考虑这样一个例子:

    Lb: f1[B E] f2[F G] f3[H I] f4[J M]
    Lo: f5[A C] f6[D K] f7[L O]
 
如果我们最初在步骤3中选择f2，现在我们将压缩f2(input)和f6(output_level_input in step 4)，但是我们可以安全地压缩f2、f3和f6，而不扩展输出级别。

8.input和output_level_input中的文件是这个级别压缩的候选文件。

干杯!